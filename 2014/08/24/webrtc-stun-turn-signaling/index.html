<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>




  <meta name="keywords" content="STUN,TURN,webrtc," />



  <link rel="alternate" href="/atom.xml" title="X1a0 L0nG's" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3F3f6ada2bbb8c916abb3b9fa24ed6e50b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <title> (译)WebRTC实战： STUN, TURN, Signaling // X1a0 L0nG's </title>
</head>

<body>
  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->

  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">X1a0 L0nG's</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<div class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
<form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'sTHn8D3S6HPZ_z3DJe9i','2.0.0');
</script>

<div class="site-search-toggle"></div>
    </div>
  
</div>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              (译)WebRTC实战： STUN, TURN, Signaling
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2014-08-24
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/08/24/webrtc-stun-turn-signaling/#comments" >
              <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2014/08/24/webrtc-stun-turn-signaling/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <p>原文：<a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank" rel="external">WebRTC in the real world: STUN, TURN and signaling</a> By <a href="http://www.html5rocks.com/profiles/#dutton" target="_blank" rel="external">Sam Dutton</a></p>
<p>WebRTC 实现了网页点对点交流。<br>但是…<br>WebRTC 仍然需要服务器来:</p>
<ul>
<li>交换客户端元数据协调通讯，即信令(Signaling)。  </li>
<li>应对NATs(Network Address Translators) 和防火墙。  </li>
</ul>
<p>本文将向你展示如何建立一个信令服务器，并使用STUN和TURN服务器来处理实际应用中出现的一些怪异的连接问题。也将解释WebRTC应用是如何处理多方通讯并与类似VoIP、PSTN的服务互动的。</p>
<p>如果你没有了解过WebRTC，我强烈建议你在看这篇文章之前先看看<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank" rel="external">这篇文章 Getting Started With WebRTC</a><br><a id="more"></a></p>
<h4 id="什么是信令？">什么是信令？</h4><p>信令即协调通讯的过程。WebRTC应用要发起一个对话，客户端就需要交换如下信息:</p>
<ul>
<li>用于打开和关闭通讯的会话信息；</li>
<li>错误信息；</li>
<li>媒体元数据如编解码器及其设置，带宽和媒体类型；</li>
<li>秘钥数据，用于创建安全连接；</li>
<li>网络数据，如外部能访问的主机IP和端口。</li>
</ul>
<p>这个信令过程需要客户端之间能来回传递消息，但是WebRTC APIs并没有提供这种机制的实现，你需要自己创建。下面将描述建立信令服务器的几种方式。不管怎么样，先来点上下文吧…</p>
<h5 id="为什么WebRTC不提供信令实现？">为什么WebRTC不提供信令实现？</h5><p>为了避免冗余，以及做到与现有技术的最大兼容，信令方法和协议都不由WebRTC标准来指定。这些都由JSEP(<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-jsep-03#section-1.1" target="_blank" rel="external">JavaScript Session Establishment Protocol</a>)来概述.</p>
<blockquote>
<p> WebRTC呼叫建立背后的想法已经是完全指定和控制媒体链接，但是尽量托管和应用间的信令连接。<br>由是不同的应用可能会喜欢用不同的协议，比如已存在的SIP、Jungle信令协议，或者也许为了一些新奇的用例而做的特殊应用而自定义的协议。<br>这一节文字要传达的关键信息点是多媒体会话的描述，这个描述指定了必要的传输和建立媒体链接所必要的媒体配置信息。</p>
</blockquote>
<p>JSEP的架构也避免了让浏览器去保存状态，那就是，像一个信令状态机一样工作。这里也许会有一个问题，比如，当页面被刷新时，信令数据会丢失。不过，也可以把这些信令状态存在服务器。</p>
<p><img src="http://7xkc1e.com1.z0.glb.clouddn.com/jsep.png" alt="alt"></p>
<h5 id="JSEP_architecture"><center>JSEP architecture</center></h5><p>JSEP需要offer和answer之间做出之前提到的媒体元数据的信息交换。offer和answer通过Session Description Protocol(SDP)格式来沟通，如下</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">v</span>=0</span><br><span class="line"><span class="constant">o</span>=- 7614219274584779017 2 IN IP4 127.0.0.1</span><br><span class="line"><span class="constant">s</span>=-</span><br><span class="line"><span class="constant">t</span>=0 0</span><br><span class="line"><span class="constant">a</span>=group:BUNDLE audio video</span><br><span class="line"><span class="constant">a</span>=msid-semantic: WMS</span><br><span class="line"><span class="constant">m</span>=audio 1 RTP/SAVPF 111 103 104 0 8 107 106 105 13 126</span><br><span class="line"><span class="constant">c</span>=IN IP4 0.0.0.0</span><br><span class="line"><span class="constant">a</span>=rtcp:1 IN IP4 0.0.0.0</span><br><span class="line"><span class="constant">a</span>=ice-ufrag:W2TGCZw2NZHuwlnf</span><br><span class="line"><span class="constant">a</span>=ice-pwd:xdQEccP40E+P0L5qTyzDgfmW</span><br><span class="line"><span class="constant">a</span>=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level</span><br><span class="line"><span class="constant">a</span>=mid:audio</span><br><span class="line"><span class="constant">a</span>=rtcp-mux</span><br><span class="line"><span class="constant">a</span>=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:9c1AHz27dZ9xPI91YNfSlI67/EMkjHHIHORiClQe</span><br><span class="line"><span class="constant">a</span>=rtpmap:111 opus/48000/2</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p>想知道SDP的格式的所有明确含义，可以看看这个<a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1" target="_blank" rel="external">IETF examples</a>.<br>请记住WebRTC被设计使得offer或answer可以在被拧在一起之前通过编辑SDP文本来设置好本地或远程描述。比如<a href="https://apprtc.appspot.com/js/main.js" target="_blank" rel="external">apprtc.appspot.com</a>中的<code>preferAudioCodec()</code>方法就被用于设置默认的编解码器和比特率。SDP用Javascript来操作是有点痛苦，所以现在有个讨论是关于WebRTC的未来版本是否可以用JSON格式来替代，不过这里提到了一些坚持使用SDP的<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-jsep-03#section-3.3" target="_blank" rel="external">好处</a>。</p>
<h5 id="RTCPeerConnection_+_信令:_offer,_answer_and_candidate">RTCPeerConnection + 信令: offer, answer and candidate</h5><p>RTCPeerConnection接口被WebRTC应用用于创建各点之间的连接并交流视音频信息。<br>要开始这个过程RTCPeerConnection需要先做两个工作：</p>
<ul>
<li>确定本地媒体情况，比如分辨率和编解码器的能力。这些元数据会用在offeranswer机制中。</li>
<li>获取可能的应用主机网络地址，就死所谓的candidate。</li>
</ul>
<p>当本地信息被确认后，就会通过信令系统与远程终端进行交换。<br>联想下<a href="http://xkcd.com/177/" target="_blank" rel="external">alice is trying to call Eve</a>这幅漫画，发起/响应机制在其中完整的展现出来：</p>
<ul>
<li>Alice创建一个RTCPeerConnection对象。</li>
<li>Alice通过RTCPeerConnection的createOffer()方法创建一个offer(SDP会话描述)。</li>
<li>Alice通过这个offer调用setLocalDescription()。</li>
<li>Alice将offer字符串化并通过信令服务器发给Eve。</li>
<li>Eve通过调用setRemoteDescription()设置Alice的offer,来让自己的RTCPeerConnection知道Alice的设置。</li>
<li>Eve调用createAnswer()和成功回调函数来传递Eve的本地会话描述—answer。</li>
<li>Eve通过setLocalDescription()来将她的本地描述设置到她的answer中。</li>
<li>然后Eve将她字符串化后的answer通过信令服务器发回给Alice。</li>
<li>Alice通过setRemoteDescription()将Eve的anwser设置为远程会话描述。</li>
</ul>
<p>Alice和Eve还需要交换网络信息。’finding candidates’就是通过<a href="http://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment" target="_blank" rel="external">ICE框架</a>找到网络链接和端口的过程。</p>
<ul>
<li>Alice 通过onicecandidate事件处理器来创建RTCPeerConnection对象。</li>
<li>这个事件处理器将在candidates可用时被调用。</li>
<li>在这个处理器中，Alice通过信令服务器将candidate数据字符串化后发送给Eve。</li>
<li>当Eve得到Alice的candidate信息，她将调用addIceCandidate()方法将这个candidate加入自己的远程终端描述中。<br>JSEP支持<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-jsep-03#section-3.4.1" target="_blank" rel="external">ICE Candidate Trickling</a>, 这个可以使呼叫者在初始化offer之后增量的提供candidates给被呼叫者，被呼叫者在这个呼叫中直接开始设置链接而不用等待收到其他candidates。</li>
</ul>
<h5 id="编写WebRTC信令服务">编写WebRTC信令服务</h5><p>下面是一个简略的信令过程<a href="http://www.w3.org/TR/webrtc/#simple-peer-to-peer-example" target="_blank" rel="external">W3C代码示例</a>。这片代码假设已经存在一些信令机制，如SignalingChannel. 下面讨论信令的一些详细细节。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> signalingChannel = <span class="keyword">new</span> SignalingChannel();</span><br><span class="line"><span class="keyword">var</span> configuration = &#123;</span><br><span class="line">  <span class="string">'iceServers'</span>: [&#123;</span><br><span class="line">    <span class="string">'url'</span>: <span class="string">'stun:stun.example.org'</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> pc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call start() to initiate</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pc = <span class="keyword">new</span> RTCPeerConnection(configuration);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send any ice candidates to the other peer</span></span><br><span class="line">  pc.onicecandidate = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt.candidate)</span><br><span class="line">      signalingChannel.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        <span class="string">'candidate'</span>: evt.candidate</span><br><span class="line">      &#125;));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// let the 'negotiationneeded' event trigger offer generation</span></span><br><span class="line">  pc.onnegotiationneeded = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pc.createOffer(localDescCreated, logError);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// once remote stream arrives, show it in the remote video element</span></span><br><span class="line">  pc.onaddstream = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    remoteView.src = URL.createObjectURL(evt.stream);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get a local stream, show it in a self-view and add it to be sent</span></span><br><span class="line">  navigator.getUserMedia(&#123;</span><br><span class="line">    <span class="string">'audio'</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'video'</span>: <span class="literal">true</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">    selfView.src = URL.createObjectURL(stream);</span><br><span class="line">    pc.addStream(stream);</span><br><span class="line">  &#125;, logError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">localDescCreated</span>(<span class="params">desc</span>) </span>&#123;</span><br><span class="line">  pc.setLocalDescription(desc, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    signalingChannel.send(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="string">'sdp'</span>: pc.localDescription</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;, logError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signalingChannel.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!pc)</span><br><span class="line">    start();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> message = <span class="built_in">JSON</span>.parse(evt.data);</span><br><span class="line">  <span class="keyword">if</span> (message.sdp)</span><br><span class="line">    pc.setRemoteDescription(<span class="keyword">new</span> RTCSessionDescription(message.sdp), <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// if we received an offer, we need to answer</span></span><br><span class="line">      <span class="keyword">if</span> (pc.remoteDescription.type == <span class="string">'offer'</span>)</span><br><span class="line">        pc.createAnswer(localDescCreated, logError);</span><br><span class="line">    &#125;, logError);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    pc.addIceCandidate(<span class="keyword">new</span> RTCIceCandidate(message.candidate));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logError</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  log(error.name + <span class="string">': '</span> + error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要知道这片代码中offer/answer和candidate交换过程是如何运作的，可以看看<a href="http://simpl.info/rtcpeerconnection/" target="_blank" rel="external">simpl.info/pc</a> 中视频聊天示例的控制台记录。如果你需要跟多细节，可以下载完整的WebRTC信令转储，并通过Chrome的 chrome://webrtc-internals 或Opera的 opera://webrtc-internals 页面来统计。</p>
<h5 id="终端的发现">终端的发现</h5><p>要说清楚’我怎么才能找到某人来聊天’挺复杂的。<br>对于电话来说，我们有电话号码目录。对于在线视频聊天，我们需要身份认证以及在线状态管理系统，即用户初始化会话。WebRTC应用需要一种方式来让客户端来互相标识他们是像创建一个聊天室还是加入一个聊天。</p>
<p>WebRTC没有提供终端目录机制，所以我们不会进入这一项。这个过程可以简单的通过邮件或信息分享一个URL，比如 <a href="http://talky.io/" target="_blank" rel="external">talky.io</a>、<a href="http://tawk.com/" target="_blank" rel="external">tawk.com</a> 和 <a href="http://browsermeeting.com/" target="_blank" rel="external">browsermeeting.com</a>这些视频聊天应用中，你邀请别人加入是通过跟他们分享你的自有链接。开发者Chris Ball创建了一个有趣的实验<a href="http://blog.printf.net/articles/2013/05/17/webrtc-without-a-signaling-server/" target="_blank" rel="external">serverless-webrtc</a>让WebRTC的参与者通过IM,email或者信鸽来交换元数据。</p>
<h4 id="要如何建立一个信令服务器?">要如何建立一个信令服务器?<p></p></h4><p>重申一下，信令协议及机制并不由WebRTC标准定义。不管你选择什么，你都需要一个中介服务器来交换客户端之间的信令信息和应用数据。很可惜，网页应用并不能简单的直接冲着英特网说’把我和我的朋友连起来！’．</p>
<p>还好信令信息很小，并且大多数只在一个呼叫的开始才需要交换．在对<a href="http://apprtc.appspot.com/" target="_blank" rel="external">apprtc.appspot.com</a>和<a href="http://samdutton-nodertc.jit.su/" target="_blank" rel="external">samdutton-nodertc.jit.su</a>的测试中我们发现，一个视频聊天会话中，信令服务器总共处理了30-45条消息，所有消息的总大小才10kb左右。</p>
<p>并且对带宽的要求也较低，WebRTC信令服务器并不消耗太多cpu或内存，因为它们只需要做消息中转，并保存少量的会话状态数据(例如，有哪些客户已经连接了)。</p>
<blockquote>
<p><strong>Tip!</strong><br>信令机制可以用来交换会话元数据，也可以用来做应用数据通讯。它就是一个消息服务器。</p>
</blockquote>
<h5 id="从服务器推送消息到客户端">从服务器推送消息到客户端</h5><p>信令的消息服务需要是双向的：客户端发到服务器且服务器发到客户端。双向通讯违反了HTTP协议的客户/服务，请求/响应模型。不过一些hack，比如为了将数据从服务器推送到网页的<a href="https://en.wikipedia.org/wiki/Comet_(programming" target="_blank" rel="external">长轮询</a>)已经出现很多年了。</p>
<p>最近，<a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/" target="_blank" rel="external">EventSource API</a>已被广泛的应用了，他使得服务器通过HTTP发送数据到浏览器成为可能。这里有个简单的<a href="http://simpl.info/es" target="_blank" rel="external">demo</a>。EventSource被设计成单向传递消息，但是它可以和XHR结合构建成交换信令消息的服务器:一个从呼叫者开始传递消息，用XHR请求传输，通过EventSource推送到被呼叫者那去。</p>
<p><a href="http://www.html5rocks.com/en/tutorials/websockets/basics/" target="_blank" rel="external">WebSocket</a>是一个更自然的解决方案，被设计成全双工的客户端/服务器通讯(消息可以同时双向传输)。一个将信令服务器用纯WebSocket或服务器发送事件(EventSource)的型式构建的好处是后台接口可以由各种语言的通用框架公共托管包来实现，比如PHP,Python和Ruby。</p>
<p>大概四分之三的浏览器都<a href="http://caniuse.com/#search=websocket" target="_blank" rel="external">支持WebSocket</a>了，更重要的是，所有支持WebRTC的浏览器都支持WebSocket,不管是桌面端还是移动端。所有连接都需要使用<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">TLS</a>，去保证不被截获到未加密的信息，并且减少<a href="http://en.wikipedia.org/wiki/WebSocket#Proxy_traversal" target="_blank" rel="external">proxy traveral</a>引起的问题。(需要更多WebSocket和proxy traversal相关的信息，可以看看Ilya Grigorik的<em>High Performance Browser Networking</em>一书的<a href="http://hpbn.co/webrtc" target="_blank" rel="external">WebRTC章节</a>。Peter Lubber的<a href="http://refcardz.dzone.com/refcardz/html5-websocket" target="_blank" rel="external">WebSocket Cheat Sheet</a>有更多关于WebSocket客户端和服务器端的信息)。</p>
<p><a href="http://apprtc.appspot.com/" target="_blank" rel="external">apprtc.appspot.com</a>WebRTC视频聊天应用的信令是通过<a href="https://developers.google.com/appengine/docs/java/channel/" target="_blank" rel="external">Google App Engine Channel API</a>完成的，这个API用到了<a href="http://en.wikipedia.org/wiki/Comet_(programming" target="_blank" rel="external">Comet</a>)技术(长轮询)去实现信令推送信息(这里有一个App Engine为支持WebSocket<a href="https://code.google.com/p/googleappengine/issues/detail?id=2535" target="_blank" rel="external">存在很久的bug</a>,快去关注这个bug，给它投票别让它沉了!)。<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank" rel="external">这里</a>有一份这个应用的详细代码。</p>
<p>WebRTC客户端通过ajax轮询获取服务器信息处理信令也是可行的，但是这导致太多冗余的网络请求，尤其对于移动端客户来说更是一个问题。甚至在一个会话建立之后，终端仍需要轮询信令信息去查询是否会话有变化或者会话是否被对方终止了。这个<a href="http://webrtcbook.com/" target="_blank" rel="external">示例</a>使用了该方法，但做了一些轮询频率的优化。</p>
<h5 id="扩展信令服务器规模">扩展信令服务器规模</h5><p>虽然信令服务器对于每个客户来说消耗的带宽和CPU都较少，但是应用流行起来的话依然要处理不同地域的大量的数据，应对高并发。通信量较高的WebRTC应用需要能够应对高负载。</p>
<p>这里我们不会讨论细节，但仍有如下一些为高容量，高性能信息可以注意的点。</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Xmpp" target="_blank" rel="external">eXtensible Messaging and Presence Protocol (XMPP)</a>, 最初被称为Jabber: 一个为即时信息开发的协议，可应用于信令服务，这种XMPP服务器的实现包括<a href="http://en.wikipedia.org/wiki/Ejabberd" target="_blank" rel="external">ejabberd</a>和<a href="http://en.wikipedia.org/wiki/Openfire" target="_blank" rel="external">Openfire</a>.JavaScript客户端如<a href="http://strophe.im/strophejs/" target="_blank" rel="external">Strophe.js</a>使用<a href="http://en.wikipedia.org/wiki/BOSH" target="_blank" rel="external">BOSH</a>模拟双向流，但是因为<a href="http://stackoverflow.com/questions/7327153/xmpp-bosh-vs-comet" target="_blank" rel="external">各种原因</a>，BOSH的效率比不上WebSocket，而且也不易扩展。(话说<a href="http://en.wikipedia.org/wiki/Jingle_(protocol" target="_blank" rel="external">Jingle</a>)是一个使XMPP支持音频和视频的扩展;WebRTC项目使用的网络传输组件<a href="https://developers.google.com/talk/libjingle/" target="_blank" rel="external">libjingle</a>库就是Jingle的C++实现)</li>
<li>开源库如<a href="http://zeromq.org/" target="_blank" rel="external">ZeroMQ</a>(TokBox用在他们的<a href="http://www.tokbox.com/blog/tokbox-builds-it%E2%80%99s-own-internal-messaging-infrastructure/" target="_blank" rel="external">Rumour</a>服务器上)和<a href="http://en.wikipedia.org/wiki/Open_Message_Queue" target="_blank" rel="external">OpenMQ</a>。<a href="http://avalanche123.com/blog/2012/02/25/interacting-with-zeromq-from-the-browser/" target="_blank" rel="external">NullMQ</a>在Web平台应用了ZeroMQ的概念，基于WebSocket使用<a href="http://stomp.github.io/" target="_blank" rel="external">STOMP</a>。</li>
<li>使用WebSocket的商业云消息平台(虽然他们不使用长轮询)如<a href="http://pusher.com/" target="_blank" rel="external">Pusher</a>, <a href="http://kaazing.com/" target="_blank" rel="external">Kaazing</a>和<a href="http://pubnub.com/" target="_blank" rel="external">PubNub</a>。(PubNub还有<a href="https://github.com/pubnub/webrtc" target="_blank" rel="external">WebRTC的接口</a>)</li>
</ul>
<p>(开发者Phil Leggetter的<a href="http://www.leggetter.co.uk/real-time-web-technologies-guide" target="_blank" rel="external">Real-Time Web Technologies Guide</a>提供了一个关于消息服务和代码库的总结性清单。)</p>
<h5 id="在Node上用Socket-io建立信令服务器">在Node上用Socket.io建立信令服务器</h5><p>以下的简单网页应用代码使用到了基于<a href="http://nodejs.org/" target="_blank" rel="external">Node</a>上的<a href="http://socket.io/" target="_blank" rel="external">Socket.io</a>而建立的信令服务器。Socket.io的设计使建立信息交换服务器变得简单，而且它尤其适用于WebRTC信令服务器，因为它内置了’房间’的概念。这个例子不是为产品级别的信令服务器设计的，但是它面向相对较小的用户群工作得很好。</p>
<p>Socket.io除了用WebSocket，还适配以下备用技术:Adobe Flash Socket, AJAX long polling, AJAX multipart streaming, Forever Iframe and JSONP polling. 它有多种后台实现，但是它的Node版本应该是最著名的，我们下面的例子就用的这个版本。</p>
<p>例子中没有WebRTC，这里只是展示网页应用信令该如何设计。查看控制台可以看到客户是如何加入一个房间且交换信息的。我们的<a href="https://bitbucket.org/webrtc/codelab" target="_blank" rel="external">WebRTC codelab</a>有如何将这个例子集成进完整的WebRTC视频聊天应用的步骤。你可以在<a href="https://bitbucket.org/webrtc/codelab/src/master/complete/step5" target="_blank" rel="external">codelab repo第五步</a>下载这些代码，也可以在<a href="http://samdutton-nodertc.jit.su/" target="_blank" rel="external">samdutton-nodertc.jit.su</a>在线试试效果。</p>
<p>index.html的代码如下:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>WebRTC client<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">'/socket.io/socket.io.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">'js/main.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>html中引用的的JavaScript文件main.js代码如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isInitiator;</span><br><span class="line"></span><br><span class="line">room = prompt(<span class="string">'Enter room name:'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> socket = io.connect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (room !== <span class="string">''</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Joining room '</span> + room);</span><br><span class="line">  socket.emit(<span class="string">'create or join'</span>, room);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'full'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">room</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Room '</span> + room + <span class="string">' is full'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'empty'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">room</span>)</span>&#123;</span><br><span class="line">  isInitiator = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Room '</span> + room + <span class="string">' is empty'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'join'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">room</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Making request to join room '</span> + room);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'You are the initiator!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'log'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, array);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>完整的服务端应用代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> static = <span class="built_in">require</span>(<span class="string">'node-static'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> file = <span class="keyword">new</span>(static.Server)();</span><br><span class="line"><span class="keyword">var</span> app = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  file.serve(req, res);</span><br><span class="line">&#125;).listen(<span class="number">2013</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>).listen(app);</span><br><span class="line"></span><br><span class="line">io.sockets.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// convenience function to log server messages to the client</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = [<span class="string">'&gt;&gt;&gt; Message from server: '</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">      array.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">      socket.emit(<span class="string">'log'</span>, array);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">    log(<span class="string">'Got message:'</span>, message);</span><br><span class="line">    <span class="comment">// for a real app, would be room only (not broadcast)</span></span><br><span class="line">    socket.broadcast.emit(<span class="string">'message'</span>, message);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  socket.on(<span class="string">'create or join'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">room</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numClients = io.sockets.clients(room).length;</span><br><span class="line"></span><br><span class="line">    log(<span class="string">'Room '</span> + room + <span class="string">' has '</span> + numClients + <span class="string">' client(s)'</span>);</span><br><span class="line">    log(<span class="string">'Request to create or join room '</span> + room);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numClients === <span class="number">0</span>)&#123;</span><br><span class="line">      socket.join(room);</span><br><span class="line">      socket.emit(<span class="string">'created'</span>, room);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numClients === <span class="number">1</span>) &#123;</span><br><span class="line">      io.sockets.in(room).emit(<span class="string">'join'</span>, room);</span><br><span class="line">      socket.join(room);</span><br><span class="line">      socket.emit(<span class="string">'joined'</span>, room);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// max two clients</span></span><br><span class="line">      socket.emit(<span class="string">'full'</span>, room);</span><br><span class="line">    &#125;</span><br><span class="line">    socket.emit(<span class="string">'emit(): client '</span> + socket.id + <span class="string">' joined room '</span> + room);</span><br><span class="line">    socket.broadcast.emit(<span class="string">'broadcast(): client '</span> + socket.id + <span class="string">' joined room '</span> + room);</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>(你并不需要知道这代码中的node-static是啥，它只是让服务器代码简单点。)<br>要在本地启动这个应用，你需要安装Node, socket.io和<a href="https://github.com/cloudhead/node-static" target="_blank" rel="external">node-static</a>。Node可以直接在<a href="http://nodejs.org/" target="_blank" rel="external">官网</a>下载(安装过程很简单)。要安装socket.io和node-static，在你的应用目录终端运行Node包管理器(NPM)就行了.</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> socket.io</span><br><span class="line">npm <span class="keyword">install</span> node-static</span><br></pre></td></tr></table></figure>
<p>要运行应用，只需要在你应用目录里终端运行如下命令:</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node <span class="keyword">server</span>.js</span><br></pre></td></tr></table></figure>
<p>在你的浏览器中打开<code>localhost:2013</code>。在新的标签页或窗口将<code>localhost:2013</code>再打开一次。看看发生了什么，检查下Chrome或Opera的控制台，你可以用通过快捷键<code>Command-Option-J</code>或<code>Ctrl-Shift-J</code>来打开开发者工具DevTool。</p>
<p>不管你选择什么来实现你的信令，你的后台和客户端都至少至少需要提供一个和这个例子类似的服务。</p>
<h5 id="在信令服务器中使用RTCDataChannel">在信令服务器中使用RTCDataChannel</h5><p>信令服务器需要初始化一个WebRTC会话。</p>
<p>然而，当两个终端间的连接建立后，RTCDataChannel理论上可以当作信令通道。这个可以减少信令的延迟并且减少信令服务器带宽和cpu的消耗，因为这样的信息是直接交流的。这里我们没有demo，不过大家仍需留意。</p>
<h5 id="信令陷阱?">信令陷阱?</h5><ul>
<li>在<code>setLocalDescription()</code>方法被调用前RTCPeerConnection都不会开始收集candidates,这是<a href="http://tools.ietf.org/html/draft-ietf-rtcweb-jsep-03#section-4.2.4" target="_blank" rel="external">JSEP IRTF draft</a>中要求的。</li>
<li>利用Trickle ICE(见前文):收到candidates信息立刻调用<code>addIceCandidate()</code>方法。</li>
</ul>
<h5 id="现成的信令服务器">现成的信令服务器</h5><p>如果你不想你自己来做信令服务器，这里有提供一些WebRTC信令服务器，用的也是之前提到的Socket.io，并都集成了WebRTC客户端JavaScript代码库。</p>
<ul>
<li><a href="https://github.com/webRTC/webRTC.io" target="_blank" rel="external">webRTC.io</a>:WebRTC的第一个抽象代码库</li>
<li><a href="https://github.com/priologic/easyrtc" target="_blank" rel="external">easyRTC</a>:全栈WebRTC包</li>
<li><a href="https://github.com/andyet/signalmaster" target="_blank" rel="external">Signalmaster</a>:为<a href="https://github.com/HenrikJoreteg/SimpleWebRTC" target="_blank" rel="external">SimpleWebRTC</a>JavaScript库创建的信令服务器。</li>
</ul>
<p>…如果你压根任何代码都不想写，这里也有一些完全商业化的WebRTC平台如<a href="http://www.vline.com/" target="_blank" rel="external">vLine</a>, <a href="http://tokbox.com/opentok" target="_blank" rel="external">OpenTok</a>,<a href="https://wiki.asterisk.org/wiki/display/AST/Asterisk+WebRTC+Support" target="_blank" rel="external">Asterisk</a>.</p>
<p>需要指出来，Ericsson在WebRTC早期就已经用<a href="https://labs.ericsson.com/blog/a-web-rtc-tutorial" target="_blank" rel="external">PHP在Apache上搭了个信令服务器</a>。但是这个现在多少已经废弃了，不过如果你在考虑做类似的事的话，这代码还是值得一看的。</p>
<h5 id="信令安全">信令安全</h5><blockquote>
<p>Security is the art of makeing nothing happen.<br>—<a href="http://t.co/S9cUM7bVfd" target="_blank" rel="external">Salman Rushdie</a></p>
</blockquote>
<p>加密在WebRTC组件中是强制的。</p>
<p>然而，信令机制并不由WebRTC标准所定义，所以让信令更安全就是你自己的事了。如果攻击者试图劫持信令, HTTPS和WSS(i.e TLS),可以保证他们不会拦截到未加密的信息。你也要注意不要在其他用同一个服务器的用户能访问到的地方广播信令信息。</p>
<blockquote>
<p>要保护WebRTC应用，在信令中使用<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="external">TLS</a>是绝对必要的。</p>
</blockquote>
<h4 id="信令之外:使用ICE应付NAT和防火墙">信令之外:使用ICE应付NAT和防火墙</h4><p>对于信令元数据，WebRTC应用使用了中介服务器，但是对于会话建立后的真正媒体数据流，RTCPeerConnection试图让客户终端直连:点对点连接。<br>简单的情况下，每个WebRTC终端都有一个唯一的地址，可以使得各终端都能互相直接通讯。<br>{}<img src="http://7xkc1e.com1.z0.glb.clouddn.com/p2p.png" alt="p2p"></p>
<h5 id="没有NAT和防火墙的情况"><center>没有NAT和防火墙的情况</center></h5><p>但是大多数设备都处于一层或多层<a href="http://www.howstuffworks.com/nat.htm" target="_blank" rel="external">NAT(网络地址转换器)</a>之后，还有杀毒软件的阻挡了一些端口或协议，又或者使用了代理或者防火墙。防火墙和NAT事实上可能在同一设备上，比如家庭无线路由器。<br><img src="http://7xkc1e.com1.z0.glb.clouddn.com/nat.png" alt="nat"></p>
<h5 id="实际情况"><center>实际情况</center></h5><p>WebRTC应用可以使用<a href="https://en.wikipedia.org/wiki/Interactive_Connectivity_Establishment" target="_blank" rel="external">ICE</a>框架来克服实际应用中复杂的网络问题。要使用ICE的话，你的应用必须如下所述的在RTCPeerConnection中传递ICE服务器的URL。</p>
<p>ICE试图找到连接端点的最佳路径。它并行的查找所有可能性，然后选择最有效率的一项。ICE首先用从设备操作系统和网卡上获取的主机地址来尝试连接，如果失败了(比如设备处于NAT之后)，ICE会使用从STUN 服务器获取到的外部地址，如果仍然失败，则交由TURN中继服务器来连接。</p>
<p>换句话说:</p>
<ul>
<li>STUN服务器用于获取设备的外部网络地址</li>
<li>TURN服务器是在点对点失败后用于通信中继。</li>
</ul>
<p>每一个TURN服务器都支持STUN，因为TURN就是在STUN服务器中内建了一个中继功能。ICE也可以应付NAT复杂的设定:实际上，NAR’打洞’会有不止一个公共 IP : port 地址。STUN或TURN服务器的URL由WebRTC中RTCPeerConnection的第一个参数iceServers配置对象可选指定。<a href="http://apprtc.appspot.com/" target="_blank" rel="external">apprtc.appspot.com</a>中的值是这样的:</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'iceServers'</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">'url'</span>: <span class="string">'stun:stun.l.google.com:19302'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">'url'</span>: <span class="string">'turn:192.158.29.39:3478?transport=udp'</span>,</span><br><span class="line">      <span class="string">'credential'</span>: <span class="string">'JZEOEt2V3Qb0y27GRntt2u2PAYA='</span>,</span><br><span class="line">      <span class="string">'username'</span>: <span class="string">'28224511:1379330808'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">'url'</span>: <span class="string">'turn:192.158.29.39:3478?transport=tcp'</span>,</span><br><span class="line">      <span class="string">'credential'</span>: <span class="string">'JZEOEt2V3Qb0y27GRntt2u2PAYA='</span>,</span><br><span class="line">      <span class="string">'username'</span>: <span class="string">'28224511:1379330808'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦RTCPeerConnection中有了这些信息，ICE的神奇就自动展现了: RTCPeerConnection使用ICE框架找到各端点间最合适的路径，必要时选用STUN和TURN服务器。</p>
<h5 id="STUN">STUN</h5><p>NAT在本地私有网络中为设备提供了一个IP地址，但是这个地址并不能被外部识别。没有一个公共地址的话，WebRTC终端是没有办法通信的。要解决这个问题，WebRTC使用了<a href="https://en.wikipedia.org/wiki/STUN" target="_blank" rel="external">STUN</a>。</p>
<p>STUN服务器处于公网中并有个简单任务:检查请求(来自运行于NAT之后的应用)的IP:port 地址，并且将这个地址响应回去。换句话说，NAT后的应用使用STUN服务器来找到他的IP:port 公网地址。这个过程使得WebRTC终端可以找到自己公共访问方法，并通过信令机制将之发送给其他终端，就可以创建一个直连链接。(在实践中，不同的NAT工作方式不同，并有可能有多层NAT，但是原理是一样的。)</p>
<p>STUN服务器并没有做太多东西，也不用记住很多东西，所以一个相对低规格的的STUN服务器可以处理大量的请求。</p>
<p>根据<a href="http://webrtcstats.com/" target="_blank" rel="external">webrtcstats.com</a>的调查，大部分(86%)WebRTC请求都可以通过STUN成功的创建连接，虽然对处于防火墙或者配置复杂的NAT之后的终端要低一些。<br><img src="http://7xkc1e.com1.z0.glb.clouddn.com/stun.png" alt="stun"></p>
<center>用STUN服务器获取公共IP:port 地址</center>

<h5 id="TURN">TURN</h5><p>RTCPeerConnection尝试用UDP协议建立终端间的直连。如果失败了，就尝试TCP协议，还是失败的话,TURN 服务器就会用于做终端间的数据中继。</p>
<p><strong>重申一下：TURN用于中继视频音频数据流，而不是信令数据!</strong></p>
<p>TURN服务器有公共地址，所以他可以被终端联系到，哪怕终端处于防火墙或者代理之后。TURN服务器有一个概念上简单的工作—做数据流中继—但是，不像STUN服务器，它天生需要消耗大量带宽，也就是说，TURN服务器需要很强大。<br><img src="http://7xkc1e.com1.z0.glb.clouddn.com/turn.png" alt="turn"></p>
<h5 id="STUN,TURN和信令"><center>STUN,TURN和信令</center></h5><p>这幅图展现了TURN的运作，纯STUN不能成功的话，各终端将使用TURN服务器。</p>
<h5 id="部署STUN和TURN服务器">部署STUN和TURN服务器</h5><p>Google运行了一个公用的STUN服务器用作测试，<code>stun.l.google.com:19302</code>,<a href="http://apprtc.appspot.com/" target="_blank" rel="external">apprtc.appspot.com</a>用到了它。我们建议使用rfc5766-turn-server当作产品用途的STUN/TURN服务，STUN/TURN服务器的源代码可以在<a href="https://code.google.com/p/rfc5766-turn-server/" target="_blank" rel="external">code.google.com/p/rfc5766-turn-server</a> 找到,这里也提供了一些服务器安装的相关信息链接。<a href="https://groups.google.com/forum/#!msg/discuss-webrtc/X-OeIUC0efs/XW5Wf7Tt1vMJ" target="_blank" rel="external">Amazon Web Services(AWS)也提供了WebRTC的虚拟机镜像</a>。</p>
<p>另一个备选TURN服务器是restund，有<a href="http://www.creytiv.com/restund.html" target="_blank" rel="external">源代码</a>，也可以装到在AWS上。下面是介绍如何将restund装到Google Compute Engine上。</p>
<ol>
<li>防火墙开放tcp=443,udp/tcp=3478</li>
<li>创建4个实例(?)，各自的公用IP，使用标准Ubuntu 12.06镜像</li>
<li>配置本地防火墙(允许所有访问源)</li>
<li>安装工具:<br><code>sudo apt-get install make</code><br><code>sudo apt-get install gcc</code></li>
<li>从<a href="http://creytiv.com/re.html" target="_blank" rel="external">creytiv.com/re.html</a>安装libre</li>
<li>从<a href="http://creytiv.com/restund.html" target="_blank" rel="external">creytiv.com/restund.html</a>获取restund并解包</li>
<li>wget <a href="http://hancke.name/restund-auth.patch" target="_blank" rel="external">hancke.name/restund-auth.patch</a> 并应用<code>patch -p1 &lt; restund-auth.patch</code></li>
<li>对libre和restund运行 make, <code>sudo make install</code></li>
<li>按你自己的需求配置<em>restund.conf</em>(替换IP地址，确保正确的共享密钥)并复制到<code>/etc</code>目录</li>
<li>复制<em>restund/etc/restund</em>到<em>/etc/init.d/</em></li>
<li>配置restund:<br>设置<em>LD_LIBRARY_PATH</em><br>复制<em>restund.conf</em>到<em>/etc/restund.conf</em><br>设置<em>restund.conf</em>使用之前配的IP地址</li>
<li>运行restund</li>
<li>在远程机器运行stund client命令做测试: <code>./client IP:port</code></li>
</ol>
<h4 id="点对点之外:多方WebRTC通讯">点对点之外:多方WebRTC通讯</h4><p>你也许会对Justin Uberti为<a href="http://tools.ietf.org/html/draft-uberti-rtcweb-turn-rest-00" target="_blank" rel="external">REST API for access to TURN Services</a>提出的IETF标准感兴趣。</p>
<p>很容易想到一个超越简单的点对点媒体流用例:比如,同事间的视频会议，或者一个有数百(万)用户的公共演讲。</p>
<p>WebRTC应用可以使用多RTCPeerConnection，让各终端之间以网状配置连接。这就是如<a href="http://talky.io/" target="_blank" rel="external">talky.io</a>这类应用所使用的方法，并且在少量终端的情况下运行的非常良好。不过，CPU和带宽都消耗非常多，尤其是在移动终端上。<br><img src="http://7xkc1e.com1.z0.glb.clouddn.com/mesh.png" alt="mesh"></p>
<h5 id="网状拓扑结构:所有终端都互相连接"><center>网状拓扑结构:所有终端都互相连接</center></h5><p>此外，WebRTC应用可以按星状拓扑结构来选择一个终端分发数据流。在服务器运行一个WebRTC终端来作为重新分配机制也是可行的(webrtc.org提供了一个<a href="https://code.google.com/p/webrtc/source/browse/#svn%2Ftrunk%2Ftalk" target="_blank" rel="external">简单例子</a>)。</p>
<p>从Chrome 31和Opera 18开始，RTCPeerConnection的MediaStream可以当作另一个RTCPeerConnection的输入:这里有个简单演示<a href="http://simpl.info/rtcpeerconnection/multi" target="_blank" rel="external">simpl.info/rtcpeerconnection/multi</a>, 这使得应用结构更灵活，因为它使网络应用通过选择其他终端的连接来处理路由成为可能。</p>
<h5 id="Multipoint_Control_Unit">Multipoint Control Unit</h5><p>对于大量终端的更好选择是使用<a href="https://en.wikipedia.org/wiki/Multipoint_control_unit" target="_blank" rel="external">Multipoint Control Unit(MCU)</a>.这是一个服务器，像大量参与者之间的桥梁一样用于分发媒体信息。MCU可以在一个视频会议中使用多种分辨率，编解码器和帧率，处理转换编码，选择数据流径，调制或录制视频音频。对于多方通话，有一堆问题需要注意: 特别是，如何显示多视频输入和混调多源音频。云平台如<a href="http://www.vline.com/" target="_blank" rel="external">vLine</a>有尝试优化流量路径。</p>
<p>可以考虑买一个MCU的硬件，或者自己做一个。</p>
<center><img src="http://7xkc1e.com1.z0.glb.clouddn.com/mcu.jpg" alt="mcu"></center>

<h5 id="Cisco_MCU的背面"><center><a href="http://cisco.com/en/US/products/ps12283" target="_blank" rel="external">Cisco MCU</a>的背面</center></h5><p>有不少能用的开源MCU软件供选择。比如,<a href="http://lynckia.com/" target="_blank" rel="external">Licode</a>(之前叫Lynckia)就为WebRTC做了一个开源MCU，OpenTok也有一个开源产品<a href="http://www.tokbox.com/blog/mantis-next-generation-cloud-technology-for-webrtc/" target="_blank" rel="external">Mantis</a>。</p>
<h4 id="浏览器之外:_VoIP,_电话和短信">浏览器之外: VoIP, 电话和短信</h4><p>WebRTC的标准性质使得浏览器中运行的WebRTC应用可以和运行其他通信平台的设备或者平台建立通讯，比如电话或者视频会议系统。</p>
<p><a href="http://en.wikipedia.org/wiki/Session_Initiation_Protocol" target="_blank" rel="external">SIP</a>是VoIP和视频会议系统的信令协议。要使WebRTC网页应用能和其他如视频会议系统的SIP客户端通讯，WebRTC需要一个代理服务器做中介信令。信令需要流过网关，但是一旦通信已经建立起来，SRTP(视频和音频)就可以点对点传输。</p>
<p><a href="http://en.wikipedia.org/wiki/Public_switched_telephone_network" target="_blank" rel="external">PSTN</a>(Public Switched Telephone Network)，公用电话交换网络，是所有普通模拟电话的闭路交换网络。要用WebRTC网页应用打电话，流量必须经过PSTN网关。此外，WebRTC网页应用需要用中介XMPP服务器来与<a href="http://en.wikipedia.org/wiki/Jingle_(protocol" target="_blank" rel="external">Jingle</a>)终端如即时通信客户端通讯。<br>Jingle由Google开发来作为XMPP扩展用于支持视频和音频信息:现在WebRTC的实现基于<a href="https://developers.google.com/talk/libjingle/" target="_blank" rel="external">libjingle</a> C++库，这个Jingle的实现刚开始是为Google Talk开发的。</p>
<p>一些应用，代码库和平台利用WebRTC的能力来于外界通讯，如：</p>
<ul>
<li><a href="https://code.google.com/p/sipml5/" target="_blank" rel="external">sipML5</a>：开源JavaScript SIP客户端</li>
<li><a href="http://www.jssip.net/" target="_blank" rel="external">jsSIP</a>：JavaScript SIP代码库</li>
<li><a href="http://phono.com/" target="_blank" rel="external">Phono</a>：开源JavaScript电话接口，作为插件开发</li>
<li><a href="http://zingaya.com/product/" target="_blank" rel="external">Zingaya</a>：嵌入式电话组件</li>
<li><a href="http://www.twilio.com/" target="_blank" rel="external">Twilio</a>：音频消息应用</li>
<li><a href="http://www.uberconference.com/" target="_blank" rel="external">Uberconference</a>：会议系统</li>
</ul>
<p>sipML5的开发们也开发了<a href="https://code.google.com/p/webrtc2sip/" target="_blank" rel="external">webrtc2sip</a>网关。Tethr and Tropo在笔记本上演示过一个<a href="http://tethr.tumblr.com/post/25513708436/tethr-and-tropo-in-the-google-i-o-sandbox" target="_blank" rel="external">救灾通讯框架</a>, 使用<a href="http://en.wikipedia.org/wiki/OpenBTS" target="_blank" rel="external">OpenBTS cell</a>让电脑能通过WebRTC与一个特别的电话通讯。无需电信就能打电话啦！</p>
<h4 id="更多">更多</h4><p>WebRTC <a href="https://bitbucket.org/webrtc/codelab" target="_blank" rel="external">codelab</a>：一步一步介绍如何建立一个视频文字聊天应用，使用了在Node中运行的Socket.io信令服务器。</p>
<p>2013 Google I/O 大会上由WebRTC技术组长Justin Uberti做的<a href="http://www.youtube.com/watch?v=p2HzZkd2A40" target="_blank" rel="external">WebRTC报告</a>。</p>
<p>Chris Wilson在SFHTML5上的报告:<a href="http://www.youtube.com/watch?v=3Ifbqaw5l_I" target="_blank" rel="external">Introduction to WebRTC Apps</a></p>
<p><a href="http://webrtcbook.com/" target="_blank" rel="external">WebRTC Book</a>提供了很多数据和信令路径的详细信息，包括了许多详细的网络拓扑图。</p>
<p><a href="http://www.tokbox.com/blog/webrtc-and-signaling-what-two-years-has-taught-us/" target="_blank" rel="external">WebRTC and Signaling: What Two Years Has Taught Us</a>:TokBox的一篇博文告诉我们为什么要把信令从WebRTC细则中单独拎出来。</p>
<p><a href="http://www.linkedin.com/in/strongben" target="_blank" rel="external">Ben Strong</a>的报告<a href="https://thenewcircle.com/s/post/1548/a_practical_guide_to_building_webrtc_apps_ben_strong_video" target="_blank" rel="external">A Practical Guide to Building WebRTC Apps</a>提供了很多WebRTC拓扑和基础。</p>
<p><a href="http://www.igvita.com/" target="_blank" rel="external">Ilya Grigorik</a>的<em>High Performance Browser Networking</em>一书中的<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch18.html" target="_blank" rel="external">WebRTC章节</a>深入描述了WebRTC结构，用例和性能。</p>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/STUN/"> #STUN </a>
          
            <a href="/tags/TURN/"> #TURN </a>
          
            <a href="/tags/webrtc/"> #webrtc </a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/08/24/ni-hao-shi-qi/">你好，诗祁</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/06/24/css-lazyload-against-render-pending/">在国内从googleapis拿字体得注意要lazyload啊</a>
            
          </div>
        </div>
      

      
      
    </div>
  </div>



    <div class="post-spread">
      
    </div>

    
      <div class="comments" id="comments">
        
          <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          </div>
        
      </div>
    
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="https://avatars3.githubusercontent.com/u/3275922?v=3&s=460" alt="X1a0 L0nG" />
          <p class="site-author-name">X1a0 L0nG</p>
        </div>
        <p class="site-description motion-element"></p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">20</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml">
              <i class="menu-item-icon icon-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/albertshaw" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.douban.com/people/x1a0l0ng/" target="_blank">Douban</a>
            </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>
        
      </div>

      
        <div class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是信令？"><span class="nav-number">1.</span> <span class="nav-text">什么是信令？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么WebRTC不提供信令实现？"><span class="nav-number">1.1.</span> <span class="nav-text">为什么WebRTC不提供信令实现？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSEP_architecture"><span class="nav-number">1.2.</span> <span class="nav-text">JSEP architecture</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RTCPeerConnection_+_信令:_offer,_answer_and_candidate"><span class="nav-number">1.3.</span> <span class="nav-text">RTCPeerConnection + 信令: offer, answer and candidate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#编写WebRTC信令服务"><span class="nav-number">1.4.</span> <span class="nav-text">编写WebRTC信令服务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#终端的发现"><span class="nav-number">1.5.</span> <span class="nav-text">终端的发现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#要如何建立一个信令服务器?"><span class="nav-number">2.</span> <span class="nav-text">要如何建立一个信令服务器?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#从服务器推送消息到客户端"><span class="nav-number">2.1.</span> <span class="nav-text">从服务器推送消息到客户端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#扩展信令服务器规模"><span class="nav-number">2.2.</span> <span class="nav-text">扩展信令服务器规模</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在Node上用Socket-io建立信令服务器"><span class="nav-number">2.3.</span> <span class="nav-text">在Node上用Socket.io建立信令服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在信令服务器中使用RTCDataChannel"><span class="nav-number">2.4.</span> <span class="nav-text">在信令服务器中使用RTCDataChannel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#信令陷阱?"><span class="nav-number">2.5.</span> <span class="nav-text">信令陷阱?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#现成的信令服务器"><span class="nav-number">2.6.</span> <span class="nav-text">现成的信令服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#信令安全"><span class="nav-number">2.7.</span> <span class="nav-text">信令安全</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信令之外:使用ICE应付NAT和防火墙"><span class="nav-number">3.</span> <span class="nav-text">信令之外:使用ICE应付NAT和防火墙</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#没有NAT和防火墙的情况"><span class="nav-number">3.1.</span> <span class="nav-text">没有NAT和防火墙的情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实际情况"><span class="nav-number">3.2.</span> <span class="nav-text">实际情况</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#STUN"><span class="nav-number">3.3.</span> <span class="nav-text">STUN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TURN"><span class="nav-number">3.4.</span> <span class="nav-text">TURN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#STUN,TURN和信令"><span class="nav-number">3.5.</span> <span class="nav-text">STUN,TURN和信令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#部署STUN和TURN服务器"><span class="nav-number">3.6.</span> <span class="nav-text">部署STUN和TURN服务器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#点对点之外:多方WebRTC通讯"><span class="nav-number">4.</span> <span class="nav-text">点对点之外:多方WebRTC通讯</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#网状拓扑结构:所有终端都互相连接"><span class="nav-number">4.1.</span> <span class="nav-text">网状拓扑结构:所有终端都互相连接</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Multipoint_Control_Unit"><span class="nav-number">4.2.</span> <span class="nav-text">Multipoint Control Unit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cisco_MCU的背面"><span class="nav-number">4.3.</span> <span class="nav-text">Cisco MCU的背面</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器之外:_VoIP,_电话和短信"><span class="nav-number">5.</span> <span class="nav-text">浏览器之外: VoIP, 电话和短信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更多"><span class="nav-number">6.</span> <span class="nav-text">更多</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </div>
      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2014 - 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">X1a0 L0nG</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.3"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.3"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.3" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.3" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  
  

  

    <script type="text/javascript">
      var disqus_shortname = 'x1a0l0ng';
      var disqus_identifier = '2014/08/24/webrtc-stun-turn-signaling/';
      var disqus_title = '(译)WebRTC实战： STUN, TURN, Signaling';
      var disqus_url = 'http://blog.xiaol.me/2014/08/24/webrtc-stun-turn-signaling/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  




  
  

  
  <!-- lazyload -->
  <script type="text/javascript" src="/js/lazyload.js"></script>
      <script type="text/javascript">
        jQuery(function() {          
            jQuery("#posts img").lazyload({
              placeholder:"http://www.arao.me/loading.gif",  
                effect:"fadeIn"
              });
            });
    </script>   
</body>
</html>
